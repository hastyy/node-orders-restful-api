/**
 * Requiring something a second or n-th time has no overhead because of
 * require's internal caching system.
 * For the double require('mongoose') below, this means that the first one
 * might run the module code (if it wasn't yet require in another part of the
 * application) but the second require will simply return the reference of the
 * firstly returned object.
 */
const mongoose = require('mongoose');
const { Schema } = require('mongoose');
const { isEmail } = require('validator');


const tokenSchema = new Schema({
    token: {
        type: String,
        required: true
    },
    access: {
        type: String,
        required: true
    }
});

/**
 * The Schema defines the shape of the documents (objects) within a given
 * collection.
 * 
 * Here we define how an User instance/document should look like inside of
 * the User Collection in our MongoDB database.
 */
const userSchema = new Schema({
    email: {
        type: String,
        required: true,
        unique: true,
        validate: {
            validator: isEmail,
            message: '{VALUE} is not a valid email'
        }
    },
    password: {
        type: String,
        require: true,
        trim: true,
        minlength: 6
        // TODO: Validator to require better password strength
    },
    tokens: [tokenSchema]
});

/**
 * Models are fancy constructors compiled from our Schema definitions.
 * Instances of these models represent documents which can be saved and
 * retrieved from our database.
 * All document creation and retrieval from the database is handled by these 
 * models.
 * 
 * Here we define the User model from the userSchema, which we will use
 * throughout our application as we use classes to instantiate users.
 */
const User = mongoose.model('User', userSchema);


module.exports = User;


/**
 * JWT
 * 
 * 
 * Data is an object - representation of the user
 * jwt.sign(data, secret) returns a token
 * jwt.decode(token, secret) decodes the tokens and returns the data object
 *  - if data was altered or secret doens't match, an error is thrown
 * 
 * JWT is separated in 3 parts
 * 3rd part which is the hash, is the hash of the 2nd part, the payload, which
 * is the data object
 * 
 * so the 1st two parts of the token are public information and can easily
 * be seen in https://jwt.io.
 * the 3rd part is the hash which is generated by applying the hash algorithm
 * specified in the 1st part to the concatenation of:
 *  1.  the data/payload (specified in the 2nd part)
 *  2.  the secret string that only the server knows
 * 
 * 
 * const tokenn = jwt.sign(data, secret);
 * const decoded = jwt.verify(token, secret);
 * if (decoded == data) return OK
 * else return SCAM_ALERT
 */
